#!/usr/bin/python3

tokenTypes = {
  "": False,
  "$": "CLASS_SYMBOL",
  ":": "CONNECTION",
  "#": "INSTANCE_OF",
  "*": "DEFINITION",
  "[": "OPEN_BRACE",
  "]": "CLOSE_BRACE",
  ";": "SEMICOLON",
  "hi": "HIGH_CONSTANT",
  "lo": "LOW_CONSTANT",
  "im": "IMPEDANCE_CONSTANT",
  "plu": "PULL_UP_RESISTOR",
  "pld": "PULL_DOWN_RESISTOR",
  "tri": "TRI_STATE_GATE",
  "not": "NOT_GATE",
  "and": "AND_GATE",
  "or": "OR_GATE",
  "xor": "XOR_GATE",
  "nand": "NAND_GATE",
  "nor": "NOR_GATE",
  "xnor": "XNOR_GATE"
}

rhsExprs = {
  "HIGH_CONSTANT": 0,
  "LOW_CONSTANT": 0,
  "IMPEDANCE_CONSTANT": 0,
  "PULL_UP_RESISTOR": 1,
  "PULL_DOWN_RESISTOR": 1,
  "TRI_STATE_GATE": 2,
  "NOT_GATE": 1,
  "AND_GATE": 2,
  "OR_GATE": 2,
  "XOR_GATE": 2,
  "NAND_GATE": 2,
  "NOR_GATE": 2,
  "XNOR_GATE": 2,
  "IDENT": 0
}

def throwErr(file, pos, msg, code):
  print(f"{file}:{str(pos[1])}:{str(pos[0])} - {msg}")
  exit(code)

def readFile(filename):
  with open(filename, "r") as foo:
    return foo.read()

def identifyToken(token):
  tk = token.lower()
  try:
    return tokenTypes[tk]
  except KeyError:
    return "IDENT"

class Token:
  def __init__(self, val, tkType, pos):
    self.value = val
    self.type = tkType
    self.pos = pos
    self.parent = None

    if self.type == "IDENT" and len(self.value.split(".")) > 1:
      self.parent = self.value.split(".")[:-1]
      self.value = self.value.split(".")[-1]

  def __repr__(self):
    return f"Token({{value: '{self.value}', type: '{self.type}', pos: {self.pos}}}"

def tokenise(source):
  program = readFile(source)
  token = ""
  tokens = []
  posInSrc = [0, 1] # 0th char of 1st line
  for char in program:
    posInSrc[0] += 1
    if char == "\n": 
      posInSrc[1] += 1 # increment line by one
      posInSrc[0] = 1
    if char.strip() == "" or char in list(tokenTypes.keys()):
      tkType = identifyToken(token)
      if tkType != False: tokens.append(Token(token, tkType, posInSrc.copy()))
      token = ""
      tkType = identifyToken(char.strip())
      if tkType != False: tokens.append(Token(char, tkType, posInSrc.copy()))
    else: token += char
  return tokens

def nextToken(tokenStream):
  try:
    return tokenStream.next()
  except IndexError:
    with open(SOURCE_FILE, "r") as src:
      lines = src.readlines()
    throwErr(SOURCE_FILE, [len(lines[-1]), len(lines)], "Unexpected EOF", 2)

class IC:
  def __init__(self, name):
    self.name = name
    self.locals = {}
    self.tree = []

  def addLocal(self, name, proto=None, line=None):
    if name in self.locals:
      return False
    else:  
      self.locals[name] = { "name": name, "type": proto, "defined": line }
      return True

  def addTreeExpr(self, local, op , args=None):
    if local[0].parent == None: self.addLocal(local[0].value, local[1], local[2])
    local = local[0]
    if op != None:
      newArgs = []
      for arg in args:
        if arg.type == "IDENT":
          newArgs.append({"name": arg.value, "parent": arg.parent})
      self.tree.append({ "dest": {"name": local.value, "parent": local.parent}, "op": op, "arg": newArgs, "line": local.pos[1] })

  def toDictionary(self):
    return {"name": self.name, "locals": self.locals, "tree": self.tree}

  def __repr__(self):
    return f"IC({{name: '{self.name}', locals: {self.locals}, tree: {self.tree}}})"

class Program:
  def __init__(self):
    self.ICs = {}
    self.globals = {}
    self.tree = []

  def addGlobal(self, name, proto=None, line=None):
    if name in self.globals:
      return False
    else: 
      self.globals[name] = { "name": name, "type": proto, "defined": line }
      return True

  def addTreeExpr(self, _global, op, args=None):
    if _global[0].parent == None: self.addGlobal(_global[0].value, _global[1], _global[2])
    _global = _global[0]
    if op != None:
      newArgs = []
      for arg in args:
        if arg.type == "IDENT":
          newArgs.append({"name": arg.value, "parent": arg.parent, "type": "IDENT"})
        else:
          newArgs.append({"type": arg.type})
      self.tree.append({ "dest": {"name": _global.value, "parent": _global.parent}, "op": op, "arg": newArgs, "line": _global.pos[1] })

  def addIC(self, IC):
    self.ICs[IC.name] = IC

  def toDictionary(self):
    dictICs = {}
    for ick in self.ICs: 
      dictICs[ick] = self.ICs[ick].toDictionary()  
    return {"ICs": dictICs, "globals": self.globals, "tree": self.tree}

  def __repr__(self):
    return f"Program({{ICs: '{self.ICs}', globals: {self.globals}, tree: {self.tree}}})"

class TokenStream:
  def __init__(self, tokens):
    self.index = 0
    self.tokens = tokens

  def next(self):
    item = self.tokens[self.index]
    self.index += 1
    return item

  def peek(self):
    return self.tokens[self.index]

def parseLHS(tkGen):
  nextTk = nextToken(tkGen)
  if nextTk.type == "IDENT":
    var = nextTk
    
    nextTk = nextToken(tkGen)
    if nextTk.type == "CONNECTION":
      return ((var, None, None), False)

    elif nextTk.type == "INSTANCE_OF":

      proto = nextToken(tkGen)
      if proto.type != "IDENT": throwErr(SOURCE_FILE, proto.pos, "Expected IC name", 2) 

      nextTk = nextToken(tkGen)
      if nextTk.type != "DEFINITION": throwErr(SOURCE_FILE, proto.pos, "Expected '*'", 2)

      smi = nextToken(tkGen)
      if smi.type != "SEMICOLON": throwErr(SOURCE_FILE, nextTk.pos, "Missing semicolon", 2)

      return ((var, proto.value, proto.pos[1]), True)

    elif nextTk.type == "DEFINITION":

      smi = nextToken(tkGen)
      if smi.type != "SEMICOLON": throwErr(SOURCE_FILE, nextTk.pos, "Missing semicolon", 2)

      return ((var, None, None), True)

  else:
    throwErr(SOURCE_FILE, nextTk.pos, "Expected identifier as left-hand side of assignment or defintion", 2)

def parseRHS(tkGen):
  op = nextToken(tkGen)
  if not (op.type in rhsExprs): throwErr(SOURCE_FILE, op.pos, f"Unexpected '{op.value}' in right-hand side of assignment", 2)

  if rhsExprs[op.type] == 0:
    nextTk = nextToken(tkGen)
    if nextTk.type != "SEMICOLON": throwErr(SOURCE_FILE, nextTk.pos, "Missing semicolon", 2) 

    return (op.type, [op])

  else:
    args = []
    for i in range(rhsExprs[op.type]):
      arg = nextToken(tkGen)
      if not (arg.type in ["HIGH_CONSTANT", "LOW_CONSTANT", "IMPEDANCE_CONSTANT", "IDENT"]): throwErr(SOURCE_FILE, arg.pos, f"Unexpected '{nextTk.value}' in right-hand side of assignment", 2)
      args.append(arg)

    nextTk = nextToken(tkGen)
    if nextTk.type != "SEMICOLON": throwErr(SOURCE_FILE, nextTk.pos, "Missing semicolon", 2)

    return (op.type, args)

def parseExpr(tokens):
  variable, terminated = parseLHS(tokens)
  if not terminated:
    op, arg = parseRHS(tokens)
    return (variable, op, arg)

  return (variable, None, [])

def parse(tokens):
  tkGen = TokenStream(tokens)
  program = Program()

  while tkGen.index < len(tokens):
    token = tkGen.peek()
    if token.type == "CLASS_SYMBOL":
      nextToken(tkGen)

      nextTk = nextToken(tkGen)
      if nextTk.type != "IDENT": throwErr(SOURCE_FILE, nextTk.pos, "Expected IC name", 2)
      
      curIC = IC(nextTk.value)
      
      nextTk = nextToken(tkGen)
      if nextTk.type != "OPEN_BRACE": throwErr(SOURCE_FILE, nextTk.pos, "Expected IC defintion", 2)

      while tkGen.peek().type != "CLOSE_BRACE":
        local, op, arg = parseExpr(tkGen)
        curIC.addTreeExpr(local, op, arg)

      nextToken(tkGen)
      program.addIC(curIC)

    else:
      _global, op, arg = parseExpr(tkGen)

      program.addTreeExpr(_global, op, arg)

  return program

import json
def main(argv):
  try:
    argv[1]
  except IndexError:
    print("No input file specified...")
    exit(1)

  try:
    argv[2]
  except IndexError:
    print("No output file specified...")
    exit(1)
  
  global SOURCE_FILE
  SOURCE_FILE = argv[1]
  tokens = tokenise(SOURCE_FILE)
  program = parse(tokens)
  with open(argv[2], "w+") as output:
    output.truncate(0)
    output.write(" ".join(list(map(lambda v: "{:x}".format(v), list(json.dumps(program.toDictionary()).encode("utf-8"))))))

import sys 
if __name__ == "__main__":
  main(sys.argv)